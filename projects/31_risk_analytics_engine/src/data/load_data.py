# src/data/load_data.py

import pandas as pd
import numpy as np
from pathlib import Path

RAW_DATA_PATH = Path("/Users/deborahakintoye/GitHub/quant-strat-lab/projects/31_risk_analytics_engine/data/raw/synthetic_data.csv")
INTERIM_PATH = Path("/Users/deborahakintoye/GitHub/quant-strat-lab/projects/31_risk_analytics_engine/data/interim")
PROCESSED_PATH = Path("/Users/deborahakintoye/GitHub/quant-strat-lab/projects/31_risk_analytics_engine/data/processed")

INTERIM_PATH.mkdir(parents = True, exist_ok = True)
PROCESSED_PATH.mkdir(parents = True, exist_ok = True)

def load_raw_prices(filepath: Path = RAW_DATA_PATH) -> pd.DataFrame:
    """
    Load raw price series generated by generate_synthetic.py.
    Validates:
        - no missing columns
        - datetime index
        - no all-NaN rows
    """
    df = pd.read_csv(filepath, index_col=0, parse_dates=True)

    if df.isnull().all(axis=1).any():
        raise ValueError("Found row with all NaNs. Data generation failed.")
    
    if not isinstance(df.index, pd.DatetimeIndex):
        raise TypeError("Index must be a DatetimeIndex.")

    return df

def compute_log_returns(price_df: pd.DataFrame) -> pd.DataFrame:
    """
    Compute log returns from price data.
    Logs preferred for VaR, volatility, MC, PCA.
    """
    log_ret = np.log(price_df / price_df.shift(1)).dropna()
    return log_ret


def compute_simple_returns(price_df: pd.DataFrame) -> pd.DataFrame:
    """
    Compute simple % returns.
    """
    simple_ret = price_df.pct_change().dropna()
    return simple_ret

def save_interim(df: pd.DataFrame, filename: str):
    """Save lightly cleaned data to interim folder."""
    path = INTERIM_PATH / filename
    df.to_csv(path)
    return path


def save_processed(df: pd.DataFrame, filename: str):
    """Save modelling-ready features."""
    path = PROCESSED_PATH / filename
    df.to_csv(path)
    return path

def load_prices() -> pd.DataFrame:
    """
    Main function used everywhere in the project.
    Loads raw data, performs minimal cleaning.
    """
    prices = load_raw_prices()

    # Replace any isolated NaNs via forward-fill as a safety measure
    prices = prices.ffill().bfill()

    save_interim(prices, "prices_clean.csv")

    return prices


def load_returns(return_type: str = "log") -> pd.DataFrame:
    """
    Returns a clean return series:
        return_type = 'log' or 'simple'
    """

    prices = load_prices()

    if return_type == "log":
        returns = compute_log_returns(prices)
        filename = "returns_log.csv"
    else:
        returns = compute_simple_returns(prices)
        filename = "returns_simple.csv"

    save_processed(returns, filename)

    return returns



if __name__ == "__main__":
    print("Loading prices...")
    prices = load_prices()
    print(prices.head())

    print("\nLoading log returns...")
    rets = load_returns("log")
    print(rets.head())

    print("\nâœ“ load_data.py executed successfully")
